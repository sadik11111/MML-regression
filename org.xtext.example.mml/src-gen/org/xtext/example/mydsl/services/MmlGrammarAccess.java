/*
 * generated by Xtext 2.19.0
 */
package org.xtext.example.mydsl.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.EnumLiteralDeclaration;
import org.eclipse.xtext.EnumRule;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractEnumRuleElementFinder;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class MmlGrammarAccess extends AbstractGrammarElementFinder {
	
	public class MMLModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Mml.MMLModel");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cInputAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cInputDataInputParserRuleCall_0_0 = (RuleCall)cInputAssignment_0.eContents().get(0);
		private final Assignment cAlgorithmAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cAlgorithmMLChoiceAlgorithmParserRuleCall_1_0 = (RuleCall)cAlgorithmAssignment_1.eContents().get(0);
		private final Assignment cFormulaAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cFormulaRFormulaParserRuleCall_2_0 = (RuleCall)cFormulaAssignment_2.eContents().get(0);
		private final Assignment cValidationAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cValidationValidationParserRuleCall_3_0 = (RuleCall)cValidationAssignment_3.eContents().get(0);
		
		//MMLModel:
		//	input=DataInput
		//	algorithm=MLChoiceAlgorithm
		//	formula=RFormula?
		//	validation=Validation;
		@Override public ParserRule getRule() { return rule; }
		
		//input=DataInput algorithm=MLChoiceAlgorithm formula=RFormula? validation=Validation
		public Group getGroup() { return cGroup; }
		
		//input=DataInput
		public Assignment getInputAssignment_0() { return cInputAssignment_0; }
		
		//DataInput
		public RuleCall getInputDataInputParserRuleCall_0_0() { return cInputDataInputParserRuleCall_0_0; }
		
		//algorithm=MLChoiceAlgorithm
		public Assignment getAlgorithmAssignment_1() { return cAlgorithmAssignment_1; }
		
		//MLChoiceAlgorithm
		public RuleCall getAlgorithmMLChoiceAlgorithmParserRuleCall_1_0() { return cAlgorithmMLChoiceAlgorithmParserRuleCall_1_0; }
		
		//formula=RFormula?
		public Assignment getFormulaAssignment_2() { return cFormulaAssignment_2; }
		
		//RFormula
		public RuleCall getFormulaRFormulaParserRuleCall_2_0() { return cFormulaRFormulaParserRuleCall_2_0; }
		
		//validation=Validation
		public Assignment getValidationAssignment_3() { return cValidationAssignment_3; }
		
		//Validation
		public RuleCall getValidationValidationParserRuleCall_3_0() { return cValidationValidationParserRuleCall_3_0; }
	}
	public class DataInputElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Mml.DataInput");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cDatainputKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cFilelocationAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cFilelocationSTRINGTerminalRuleCall_1_0 = (RuleCall)cFilelocationAssignment_1.eContents().get(0);
		private final Assignment cParsingInstructionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cParsingInstructionCSVParsingConfigurationParserRuleCall_2_0 = (RuleCall)cParsingInstructionAssignment_2.eContents().get(0);
		
		///*
		// * 
		// * mini DSL to read data (here CSV)
		// * mini CSV DSL
		// */ DataInput:
		//	'datainput' filelocation=STRING parsingInstruction=CSVParsingConfiguration?;
		@Override public ParserRule getRule() { return rule; }
		
		//'datainput' filelocation=STRING parsingInstruction=CSVParsingConfiguration?
		public Group getGroup() { return cGroup; }
		
		//'datainput'
		public Keyword getDatainputKeyword_0() { return cDatainputKeyword_0; }
		
		//filelocation=STRING
		public Assignment getFilelocationAssignment_1() { return cFilelocationAssignment_1; }
		
		//STRING
		public RuleCall getFilelocationSTRINGTerminalRuleCall_1_0() { return cFilelocationSTRINGTerminalRuleCall_1_0; }
		
		//parsingInstruction=CSVParsingConfiguration?
		public Assignment getParsingInstructionAssignment_2() { return cParsingInstructionAssignment_2; }
		
		//CSVParsingConfiguration
		public RuleCall getParsingInstructionCSVParsingConfigurationParserRuleCall_2_0() { return cParsingInstructionCSVParsingConfigurationParserRuleCall_2_0; }
	}
	public class CSVParsingConfigurationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Mml.CSVParsingConfiguration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSeparatorKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cSepAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cSepCSVSeparatorEnumRuleCall_1_0 = (RuleCall)cSepAssignment_1.eContents().get(0);
		
		//CSVParsingConfiguration: // we could extend it with quotes handling, encoding format, or even specificities of library used to parse it (eg pandas vs readcsv)
		//	"separator" sep=CSVSeparator;
		@Override public ParserRule getRule() { return rule; }
		
		//// we could extend it with quotes handling, encoding format, or even specificities of library used to parse it (eg pandas vs readcsv)
		//"separator" sep=CSVSeparator
		public Group getGroup() { return cGroup; }
		
		//// we could extend it with quotes handling, encoding format, or even specificities of library used to parse it (eg pandas vs readcsv)
		//"separator"
		public Keyword getSeparatorKeyword_0() { return cSeparatorKeyword_0; }
		
		//sep=CSVSeparator
		public Assignment getSepAssignment_1() { return cSepAssignment_1; }
		
		//CSVSeparator
		public RuleCall getSepCSVSeparatorEnumRuleCall_1_0() { return cSepCSVSeparatorEnumRuleCall_1_0; }
	}
	public class MLChoiceAlgorithmElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Mml.MLChoiceAlgorithm");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cMlframeworkKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cFrameworkAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cFrameworkFrameworkLangEnumRuleCall_1_0 = (RuleCall)cFrameworkAssignment_1.eContents().get(0);
		private final Keyword cAlgorithmKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cAlgorithmAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cAlgorithmMLAlgorithmParserRuleCall_3_0 = (RuleCall)cAlgorithmAssignment_3.eContents().get(0);
		
		///*
		// * mini DSL to select the ML algorithm we want 
		// * we include the choice of the targeted language/framework
		// * ML algorithms can have hyperparameters
		// * 
		// */ MLChoiceAlgorithm:
		//	'mlframework' framework=FrameworkLang
		//	'algorithm' algorithm=MLAlgorithm;
		@Override public ParserRule getRule() { return rule; }
		
		//'mlframework' framework=FrameworkLang 'algorithm' algorithm=MLAlgorithm
		public Group getGroup() { return cGroup; }
		
		//'mlframework'
		public Keyword getMlframeworkKeyword_0() { return cMlframeworkKeyword_0; }
		
		//framework=FrameworkLang
		public Assignment getFrameworkAssignment_1() { return cFrameworkAssignment_1; }
		
		//FrameworkLang
		public RuleCall getFrameworkFrameworkLangEnumRuleCall_1_0() { return cFrameworkFrameworkLangEnumRuleCall_1_0; }
		
		//'algorithm'
		public Keyword getAlgorithmKeyword_2() { return cAlgorithmKeyword_2; }
		
		//algorithm=MLAlgorithm
		public Assignment getAlgorithmAssignment_3() { return cAlgorithmAssignment_3; }
		
		//MLAlgorithm
		public RuleCall getAlgorithmMLAlgorithmParserRuleCall_3_0() { return cAlgorithmMLAlgorithmParserRuleCall_3_0; }
	}
	public class MLAlgorithmElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Mml.MLAlgorithm");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSVRParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cDTParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cRandomForestParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cSGDParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cGTBParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		
		//MLAlgorithm:
		//	SVR | DT | RandomForest | SGD | GTB;
		@Override public ParserRule getRule() { return rule; }
		
		//SVR | DT | RandomForest | SGD | GTB
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//SVR
		public RuleCall getSVRParserRuleCall_0() { return cSVRParserRuleCall_0; }
		
		//DT
		public RuleCall getDTParserRuleCall_1() { return cDTParserRuleCall_1; }
		
		//RandomForest
		public RuleCall getRandomForestParserRuleCall_2() { return cRandomForestParserRuleCall_2; }
		
		//SGD
		public RuleCall getSGDParserRuleCall_3() { return cSGDParserRuleCall_3; }
		
		//GTB
		public RuleCall getGTBParserRuleCall_4() { return cGTBParserRuleCall_4; }
	}
	public class SVRElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Mml.SVR");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cSVRAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cSVRKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cCAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cCFLOATParserRuleCall_2_1_0 = (RuleCall)cCAssignment_2_1.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cKernelKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cKernelAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cKernelSVMKernelEnumRuleCall_3_1_0 = (RuleCall)cKernelAssignment_3_1.eContents().get(0);
		
		//// TODO: additional algorithm
		//SVR:
		//	{SVR} 'SVR' ('C=' C=FLOAT)? ('kernel=' kernel=SVMKernel)?;
		@Override public ParserRule getRule() { return rule; }
		
		//{SVR} 'SVR' ('C=' C=FLOAT)? ('kernel=' kernel=SVMKernel)?
		public Group getGroup() { return cGroup; }
		
		//{SVR}
		public Action getSVRAction_0() { return cSVRAction_0; }
		
		//'SVR'
		public Keyword getSVRKeyword_1() { return cSVRKeyword_1; }
		
		//('C=' C=FLOAT)?
		public Group getGroup_2() { return cGroup_2; }
		
		//'C='
		public Keyword getCKeyword_2_0() { return cCKeyword_2_0; }
		
		//C=FLOAT
		public Assignment getCAssignment_2_1() { return cCAssignment_2_1; }
		
		//FLOAT
		public RuleCall getCFLOATParserRuleCall_2_1_0() { return cCFLOATParserRuleCall_2_1_0; }
		
		//('kernel=' kernel=SVMKernel)?
		public Group getGroup_3() { return cGroup_3; }
		
		//'kernel='
		public Keyword getKernelKeyword_3_0() { return cKernelKeyword_3_0; }
		
		//kernel=SVMKernel
		public Assignment getKernelAssignment_3_1() { return cKernelAssignment_3_1; }
		
		//SVMKernel
		public RuleCall getKernelSVMKernelEnumRuleCall_3_1_0() { return cKernelSVMKernelEnumRuleCall_3_1_0; }
	}
	public class DTElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Mml.DT");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cDTAction_0 = (Action)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Keyword cDTKeyword_1_0 = (Keyword)cAlternatives_1.eContents().get(0);
		private final Keyword cDecisionTreeKeyword_1_1 = (Keyword)cAlternatives_1.eContents().get(1);
		private final Assignment cMax_depthAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cMax_depthINTTerminalRuleCall_2_0 = (RuleCall)cMax_depthAssignment_2.eContents().get(0);
		
		//DT:
		//	{DT} ('DT' | 'DecisionTree') max_depth=INT?;
		@Override public ParserRule getRule() { return rule; }
		
		//{DT} ('DT' | 'DecisionTree') max_depth=INT?
		public Group getGroup() { return cGroup; }
		
		//{DT}
		public Action getDTAction_0() { return cDTAction_0; }
		
		//('DT' | 'DecisionTree')
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//'DT'
		public Keyword getDTKeyword_1_0() { return cDTKeyword_1_0; }
		
		//'DecisionTree'
		public Keyword getDecisionTreeKeyword_1_1() { return cDecisionTreeKeyword_1_1; }
		
		//max_depth=INT?
		public Assignment getMax_depthAssignment_2() { return cMax_depthAssignment_2; }
		
		//INT
		public RuleCall getMax_depthINTTerminalRuleCall_2_0() { return cMax_depthINTTerminalRuleCall_2_0; }
	}
	public class RandomForestElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Mml.RandomForest");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cRandomForestAction_0 = (Action)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Keyword cRandomForestKeyword_1_0 = (Keyword)cAlternatives_1.eContents().get(0);
		private final Keyword cRFKeyword_1_1 = (Keyword)cAlternatives_1.eContents().get(1);
		
		//// TODO: additional hyperparameters
		//// note: R-package CART: anova 
		//RandomForest:
		//	{RandomForest} ('RandomForest' | 'RF');
		@Override public ParserRule getRule() { return rule; }
		
		//{RandomForest} ('RandomForest' | 'RF')
		public Group getGroup() { return cGroup; }
		
		//{RandomForest}
		public Action getRandomForestAction_0() { return cRandomForestAction_0; }
		
		//('RandomForest' | 'RF')
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//'RandomForest'
		public Keyword getRandomForestKeyword_1_0() { return cRandomForestKeyword_1_0; }
		
		//'RF'
		public Keyword getRFKeyword_1_1() { return cRFKeyword_1_1; }
	}
	public class SGDElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Mml.SGD");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cSGDAction_0 = (Action)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Keyword cStochasticGradientDescentKeyword_1_0 = (Keyword)cAlternatives_1.eContents().get(0);
		private final Keyword cSGDKeyword_1_1 = (Keyword)cAlternatives_1.eContents().get(1);
		
		//// TODO: hyperparameters?
		//SGD:
		//	{SGD} ('StochasticGradientDescent' | 'SGD');
		@Override public ParserRule getRule() { return rule; }
		
		//{SGD} ('StochasticGradientDescent' | 'SGD')
		public Group getGroup() { return cGroup; }
		
		//{SGD}
		public Action getSGDAction_0() { return cSGDAction_0; }
		
		//('StochasticGradientDescent' | 'SGD')
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//'StochasticGradientDescent'
		public Keyword getStochasticGradientDescentKeyword_1_0() { return cStochasticGradientDescentKeyword_1_0; }
		
		//'SGD'
		public Keyword getSGDKeyword_1_1() { return cSGDKeyword_1_1; }
	}
	public class GTBElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Mml.GTB");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cGTBAction_0 = (Action)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Keyword cGradientBoostingRegressorKeyword_1_0 = (Keyword)cAlternatives_1.eContents().get(0);
		private final Keyword cGTBKeyword_1_1 = (Keyword)cAlternatives_1.eContents().get(1);
		
		//// TODO: hyperparameters?
		//GTB:
		//	{GTB} ('GradientBoostingRegressor' | 'GTB');
		@Override public ParserRule getRule() { return rule; }
		
		//{GTB} ('GradientBoostingRegressor' | 'GTB')
		public Group getGroup() { return cGroup; }
		
		//{GTB}
		public Action getGTBAction_0() { return cGTBAction_0; }
		
		//('GradientBoostingRegressor' | 'GTB')
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//'GradientBoostingRegressor'
		public Keyword getGradientBoostingRegressorKeyword_1_0() { return cGradientBoostingRegressorKeyword_1_0; }
		
		//'GTB'
		public Keyword getGTBKeyword_1_1() { return cGTBKeyword_1_1; }
	}
	public class FLOATElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Mml.FLOAT");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Keyword cFullStopKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		//FLOAT:
		//	INT '.' INT;
		@Override public ParserRule getRule() { return rule; }
		
		//INT '.' INT
		public Group getGroup() { return cGroup; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_0() { return cINTTerminalRuleCall_0; }
		
		//'.'
		public Keyword getFullStopKeyword_1() { return cFullStopKeyword_1; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_2() { return cINTTerminalRuleCall_2; }
	}
	public class RFormulaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Mml.RFormula");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFormulaKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cPredictiveAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cPredictiveFormulaItemParserRuleCall_1_0_0 = (RuleCall)cPredictiveAssignment_1_0.eContents().get(0);
		private final Keyword cTildeKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cPredictorsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cPredictorsXFormulaParserRuleCall_2_0 = (RuleCall)cPredictorsAssignment_2.eContents().get(0);
		
		///*
		// * mini DSL to specify "formula"
		// * inspired from R formula 
		// */ RFormula:
		//	'formula' (predictive=FormulaItem "~")? predictors=XFormula;
		@Override public ParserRule getRule() { return rule; }
		
		//'formula' (predictive=FormulaItem "~")? predictors=XFormula
		public Group getGroup() { return cGroup; }
		
		//'formula'
		public Keyword getFormulaKeyword_0() { return cFormulaKeyword_0; }
		
		//(predictive=FormulaItem "~")?
		public Group getGroup_1() { return cGroup_1; }
		
		//predictive=FormulaItem
		public Assignment getPredictiveAssignment_1_0() { return cPredictiveAssignment_1_0; }
		
		//FormulaItem
		public RuleCall getPredictiveFormulaItemParserRuleCall_1_0_0() { return cPredictiveFormulaItemParserRuleCall_1_0_0; }
		
		//"~"
		public Keyword getTildeKeyword_1_1() { return cTildeKeyword_1_1; }
		
		//predictors=XFormula
		public Assignment getPredictorsAssignment_2() { return cPredictorsAssignment_2; }
		
		//XFormula
		public RuleCall getPredictorsXFormulaParserRuleCall_2_0() { return cPredictorsXFormulaParserRuleCall_2_0; }
	}
	public class XFormulaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Mml.XFormula");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cAllVariablesParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cPredictorVariablesParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//XFormula:
		//	AllVariables | PredictorVariables;
		@Override public ParserRule getRule() { return rule; }
		
		//AllVariables | PredictorVariables
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//AllVariables
		public RuleCall getAllVariablesParserRuleCall_0() { return cAllVariablesParserRuleCall_0; }
		
		//PredictorVariables
		public RuleCall getPredictorVariablesParserRuleCall_1() { return cPredictorVariablesParserRuleCall_1; }
	}
	public class AllVariablesElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Mml.AllVariables");
		private final Assignment cAllAssignment = (Assignment)rule.eContents().get(1);
		private final Keyword cAllFullStopKeyword_0 = (Keyword)cAllAssignment.eContents().get(0);
		
		//AllVariables:
		//	all='.';
		@Override public ParserRule getRule() { return rule; }
		
		//all='.'
		public Assignment getAllAssignment() { return cAllAssignment; }
		
		//'.'
		public Keyword getAllFullStopKeyword_0() { return cAllFullStopKeyword_0; }
	}
	public class PredictorVariablesElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Mml.PredictorVariables");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cVarsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cVarsFormulaItemParserRuleCall_0_0 = (RuleCall)cVarsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cPlusSignKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cVarsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cVarsFormulaItemParserRuleCall_1_1_0 = (RuleCall)cVarsAssignment_1_1.eContents().get(0);
		
		//PredictorVariables:
		//	vars+=FormulaItem ("+" vars+=FormulaItem)*;
		@Override public ParserRule getRule() { return rule; }
		
		//vars+=FormulaItem ("+" vars+=FormulaItem)*
		public Group getGroup() { return cGroup; }
		
		//vars+=FormulaItem
		public Assignment getVarsAssignment_0() { return cVarsAssignment_0; }
		
		//FormulaItem
		public RuleCall getVarsFormulaItemParserRuleCall_0_0() { return cVarsFormulaItemParserRuleCall_0_0; }
		
		//("+" vars+=FormulaItem)*
		public Group getGroup_1() { return cGroup_1; }
		
		//"+"
		public Keyword getPlusSignKeyword_1_0() { return cPlusSignKeyword_1_0; }
		
		//vars+=FormulaItem
		public Assignment getVarsAssignment_1_1() { return cVarsAssignment_1_1; }
		
		//FormulaItem
		public RuleCall getVarsFormulaItemParserRuleCall_1_1_0() { return cVarsFormulaItemParserRuleCall_1_1_0; }
	}
	public class FormulaItemElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Mml.FormulaItem");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cColumnAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cColumnINTTerminalRuleCall_0_0 = (RuleCall)cColumnAssignment_0.eContents().get(0);
		private final Assignment cColNameAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cColNameSTRINGTerminalRuleCall_1_0 = (RuleCall)cColNameAssignment_1.eContents().get(0);
		
		//// by name or integer
		//FormulaItem:
		//	column=INT | colName=STRING;
		@Override public ParserRule getRule() { return rule; }
		
		//column=INT | colName=STRING
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//column=INT
		public Assignment getColumnAssignment_0() { return cColumnAssignment_0; }
		
		//INT
		public RuleCall getColumnINTTerminalRuleCall_0_0() { return cColumnINTTerminalRuleCall_0_0; }
		
		//colName=STRING
		public Assignment getColNameAssignment_1() { return cColNameAssignment_1; }
		
		//STRING
		public RuleCall getColNameSTRINGTerminalRuleCall_1_0() { return cColNameSTRINGTerminalRuleCall_1_0; }
	}
	public class ValidationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Mml.Validation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cStratificationAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cStratificationStratificationMethodParserRuleCall_0_0 = (RuleCall)cStratificationAssignment_0.eContents().get(0);
		private final Assignment cMetricAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cMetricValidationMetricEnumRuleCall_1_0 = (RuleCall)cMetricAssignment_1.eContents().get(0);
		
		///*
		// * mini DSL for evaluation
		// * choice of a "stratification" strategy and metric
		// */ Validation:
		//	stratification=StratificationMethod
		//	metric+=ValidationMetric+;
		@Override public ParserRule getRule() { return rule; }
		
		//stratification=StratificationMethod metric+=ValidationMetric+
		public Group getGroup() { return cGroup; }
		
		//stratification=StratificationMethod
		public Assignment getStratificationAssignment_0() { return cStratificationAssignment_0; }
		
		//StratificationMethod
		public RuleCall getStratificationStratificationMethodParserRuleCall_0_0() { return cStratificationStratificationMethodParserRuleCall_0_0; }
		
		//metric+=ValidationMetric+
		public Assignment getMetricAssignment_1() { return cMetricAssignment_1; }
		
		//ValidationMetric
		public RuleCall getMetricValidationMetricEnumRuleCall_1_0() { return cMetricValidationMetricEnumRuleCall_1_0; }
	}
	public class StratificationMethodElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Mml.StratificationMethod");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cCrossValidationParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cTrainingTestParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//StratificationMethod:
		//	CrossValidation | TrainingTest;
		@Override public ParserRule getRule() { return rule; }
		
		//CrossValidation | TrainingTest
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//CrossValidation
		public RuleCall getCrossValidationParserRuleCall_0() { return cCrossValidationParserRuleCall_0; }
		
		//TrainingTest
		public RuleCall getTrainingTestParserRuleCall_1() { return cTrainingTestParserRuleCall_1; }
	}
	public class CrossValidationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Mml.CrossValidation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCrossValidationKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cNumRepetitionCrossKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cNumberAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cNumberINTTerminalRuleCall_3_0 = (RuleCall)cNumberAssignment_3.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//CrossValidation:
		//	'CrossValidation' '{'
		//	'numRepetitionCross' number=INT
		//	'}';
		@Override public ParserRule getRule() { return rule; }
		
		//'CrossValidation' '{' 'numRepetitionCross' number=INT '}'
		public Group getGroup() { return cGroup; }
		
		//'CrossValidation'
		public Keyword getCrossValidationKeyword_0() { return cCrossValidationKeyword_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }
		
		//'numRepetitionCross'
		public Keyword getNumRepetitionCrossKeyword_2() { return cNumRepetitionCrossKeyword_2; }
		
		//number=INT
		public Assignment getNumberAssignment_3() { return cNumberAssignment_3; }
		
		//INT
		public RuleCall getNumberINTTerminalRuleCall_3_0() { return cNumberINTTerminalRuleCall_3_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }
	}
	public class TrainingTestElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Mml.TrainingTest");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cTrainingTestKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cPercentageTrainingKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cNumberAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cNumberINTTerminalRuleCall_3_0 = (RuleCall)cNumberAssignment_3.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//// TODO: can certainly be extended
		//TrainingTest:
		//	'TrainingTest' '{'
		//	'percentageTraining' number=INT
		//	'}';
		@Override public ParserRule getRule() { return rule; }
		
		//'TrainingTest' '{' 'percentageTraining' number=INT '}'
		public Group getGroup() { return cGroup; }
		
		//'TrainingTest'
		public Keyword getTrainingTestKeyword_0() { return cTrainingTestKeyword_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }
		
		//'percentageTraining'
		public Keyword getPercentageTrainingKeyword_2() { return cPercentageTrainingKeyword_2; }
		
		//number=INT
		public Assignment getNumberAssignment_3() { return cNumberAssignment_3; }
		
		//INT
		public RuleCall getNumberINTTerminalRuleCall_3_0() { return cNumberINTTerminalRuleCall_3_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }
	}
	
	public class CSVSeparatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Mml.CSVSeparator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cCOMMAEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cCOMMACommaKeyword_0_0 = (Keyword)cCOMMAEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cSEMI_COLONEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cSEMI_COLONSemicolonKeyword_1_0 = (Keyword)cSEMI_COLONEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum CSVSeparator:
		//	COMMA=',' | SEMI_COLON=";";
		public EnumRule getRule() { return rule; }
		
		//COMMA=',' | SEMI_COLON=";"
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//COMMA=','
		public EnumLiteralDeclaration getCOMMAEnumLiteralDeclaration_0() { return cCOMMAEnumLiteralDeclaration_0; }
		
		//','
		public Keyword getCOMMACommaKeyword_0_0() { return cCOMMACommaKeyword_0_0; }
		
		//SEMI_COLON=";"
		public EnumLiteralDeclaration getSEMI_COLONEnumLiteralDeclaration_1() { return cSEMI_COLONEnumLiteralDeclaration_1; }
		
		//";"
		public Keyword getSEMI_COLONSemicolonKeyword_1_0() { return cSEMI_COLONSemicolonKeyword_1_0; }
	}
	public class FrameworkLangElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Mml.FrameworkLang");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cSCIKITEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cSCIKITScikitLearnKeyword_0_0 = (Keyword)cSCIKITEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cREnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cRRKeyword_1_0 = (Keyword)cREnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cJavaWekaEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cJavaWekaWekaKeyword_2_0 = (Keyword)cJavaWekaEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cXGBoostEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cXGBoostXgboostKeyword_3_0 = (Keyword)cXGBoostEnumLiteralDeclaration_3.eContents().get(0);
		
		//enum FrameworkLang:
		//	SCIKIT="scikit-learn" | R | JavaWeka="Weka" | XGBoost="xgboost";
		public EnumRule getRule() { return rule; }
		
		//SCIKIT="scikit-learn" | R | JavaWeka="Weka" | XGBoost="xgboost"
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//SCIKIT="scikit-learn"
		public EnumLiteralDeclaration getSCIKITEnumLiteralDeclaration_0() { return cSCIKITEnumLiteralDeclaration_0; }
		
		//"scikit-learn"
		public Keyword getSCIKITScikitLearnKeyword_0_0() { return cSCIKITScikitLearnKeyword_0_0; }
		
		//R
		public EnumLiteralDeclaration getREnumLiteralDeclaration_1() { return cREnumLiteralDeclaration_1; }
		
		//"R"
		public Keyword getRRKeyword_1_0() { return cRRKeyword_1_0; }
		
		//JavaWeka="Weka"
		public EnumLiteralDeclaration getJavaWekaEnumLiteralDeclaration_2() { return cJavaWekaEnumLiteralDeclaration_2; }
		
		//"Weka"
		public Keyword getJavaWekaWekaKeyword_2_0() { return cJavaWekaWekaKeyword_2_0; }
		
		//XGBoost="xgboost"
		public EnumLiteralDeclaration getXGBoostEnumLiteralDeclaration_3() { return cXGBoostEnumLiteralDeclaration_3; }
		
		//"xgboost"
		public Keyword getXGBoostXgboostKeyword_3_0() { return cXGBoostXgboostKeyword_3_0; }
	}
	public class SVMKernelElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Mml.SVMKernel");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cLinearEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cLinearLinearKeyword_0_0 = (Keyword)cLinearEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cPolyEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cPolyPolyKeyword_1_0 = (Keyword)cPolyEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cRbfEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cRbfRbfKeyword_2_0 = (Keyword)cRbfEnumLiteralDeclaration_2.eContents().get(0);
		
		//enum SVMKernel:
		//	linear | poly | rbf;
		public EnumRule getRule() { return rule; }
		
		//linear | poly | rbf
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//linear
		public EnumLiteralDeclaration getLinearEnumLiteralDeclaration_0() { return cLinearEnumLiteralDeclaration_0; }
		
		//'linear'
		public Keyword getLinearLinearKeyword_0_0() { return cLinearLinearKeyword_0_0; }
		
		//poly
		public EnumLiteralDeclaration getPolyEnumLiteralDeclaration_1() { return cPolyEnumLiteralDeclaration_1; }
		
		//'poly'
		public Keyword getPolyPolyKeyword_1_0() { return cPolyPolyKeyword_1_0; }
		
		//rbf
		public EnumLiteralDeclaration getRbfEnumLiteralDeclaration_2() { return cRbfEnumLiteralDeclaration_2; }
		
		//'rbf'
		public Keyword getRbfRbfKeyword_2_0() { return cRbfRbfKeyword_2_0; }
	}
	public class ValidationMetricElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Mml.ValidationMetric");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cMSEEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cMSEMean_squared_errorKeyword_0_0 = (Keyword)cMSEEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cMAEEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cMAEMean_absolute_errorKeyword_1_0 = (Keyword)cMAEEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cMAPEEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cMAPEMean_absolute_percentage_errorKeyword_2_0 = (Keyword)cMAPEEnumLiteralDeclaration_2.eContents().get(0);
		
		//enum ValidationMetric:
		//	MSE='mean_squared_error' | MAE='mean_absolute_error' | MAPE="mean_absolute_percentage_error";
		public EnumRule getRule() { return rule; }
		
		//MSE='mean_squared_error' | MAE='mean_absolute_error' | MAPE="mean_absolute_percentage_error"
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//MSE='mean_squared_error'
		public EnumLiteralDeclaration getMSEEnumLiteralDeclaration_0() { return cMSEEnumLiteralDeclaration_0; }
		
		//'mean_squared_error'
		public Keyword getMSEMean_squared_errorKeyword_0_0() { return cMSEMean_squared_errorKeyword_0_0; }
		
		//MAE='mean_absolute_error'
		public EnumLiteralDeclaration getMAEEnumLiteralDeclaration_1() { return cMAEEnumLiteralDeclaration_1; }
		
		//'mean_absolute_error'
		public Keyword getMAEMean_absolute_errorKeyword_1_0() { return cMAEMean_absolute_errorKeyword_1_0; }
		
		//MAPE="mean_absolute_percentage_error"
		public EnumLiteralDeclaration getMAPEEnumLiteralDeclaration_2() { return cMAPEEnumLiteralDeclaration_2; }
		
		//"mean_absolute_percentage_error"
		public Keyword getMAPEMean_absolute_percentage_errorKeyword_2_0() { return cMAPEMean_absolute_percentage_errorKeyword_2_0; }
	}
	
	private final MMLModelElements pMMLModel;
	private final DataInputElements pDataInput;
	private final CSVParsingConfigurationElements pCSVParsingConfiguration;
	private final CSVSeparatorElements eCSVSeparator;
	private final MLChoiceAlgorithmElements pMLChoiceAlgorithm;
	private final FrameworkLangElements eFrameworkLang;
	private final MLAlgorithmElements pMLAlgorithm;
	private final SVRElements pSVR;
	private final SVMKernelElements eSVMKernel;
	private final DTElements pDT;
	private final RandomForestElements pRandomForest;
	private final SGDElements pSGD;
	private final GTBElements pGTB;
	private final FLOATElements pFLOAT;
	private final RFormulaElements pRFormula;
	private final XFormulaElements pXFormula;
	private final AllVariablesElements pAllVariables;
	private final PredictorVariablesElements pPredictorVariables;
	private final FormulaItemElements pFormulaItem;
	private final ValidationElements pValidation;
	private final StratificationMethodElements pStratificationMethod;
	private final CrossValidationElements pCrossValidation;
	private final TrainingTestElements pTrainingTest;
	private final ValidationMetricElements eValidationMetric;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public MmlGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pMMLModel = new MMLModelElements();
		this.pDataInput = new DataInputElements();
		this.pCSVParsingConfiguration = new CSVParsingConfigurationElements();
		this.eCSVSeparator = new CSVSeparatorElements();
		this.pMLChoiceAlgorithm = new MLChoiceAlgorithmElements();
		this.eFrameworkLang = new FrameworkLangElements();
		this.pMLAlgorithm = new MLAlgorithmElements();
		this.pSVR = new SVRElements();
		this.eSVMKernel = new SVMKernelElements();
		this.pDT = new DTElements();
		this.pRandomForest = new RandomForestElements();
		this.pSGD = new SGDElements();
		this.pGTB = new GTBElements();
		this.pFLOAT = new FLOATElements();
		this.pRFormula = new RFormulaElements();
		this.pXFormula = new XFormulaElements();
		this.pAllVariables = new AllVariablesElements();
		this.pPredictorVariables = new PredictorVariablesElements();
		this.pFormulaItem = new FormulaItemElements();
		this.pValidation = new ValidationElements();
		this.pStratificationMethod = new StratificationMethodElements();
		this.pCrossValidation = new CrossValidationElements();
		this.pTrainingTest = new TrainingTestElements();
		this.eValidationMetric = new ValidationMetricElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.xtext.example.mydsl.Mml".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//MMLModel:
	//	input=DataInput
	//	algorithm=MLChoiceAlgorithm
	//	formula=RFormula?
	//	validation=Validation;
	public MMLModelElements getMMLModelAccess() {
		return pMMLModel;
	}
	
	public ParserRule getMMLModelRule() {
		return getMMLModelAccess().getRule();
	}
	
	///*
	// * 
	// * mini DSL to read data (here CSV)
	// * mini CSV DSL
	// */ DataInput:
	//	'datainput' filelocation=STRING parsingInstruction=CSVParsingConfiguration?;
	public DataInputElements getDataInputAccess() {
		return pDataInput;
	}
	
	public ParserRule getDataInputRule() {
		return getDataInputAccess().getRule();
	}
	
	//CSVParsingConfiguration: // we could extend it with quotes handling, encoding format, or even specificities of library used to parse it (eg pandas vs readcsv)
	//	"separator" sep=CSVSeparator;
	public CSVParsingConfigurationElements getCSVParsingConfigurationAccess() {
		return pCSVParsingConfiguration;
	}
	
	public ParserRule getCSVParsingConfigurationRule() {
		return getCSVParsingConfigurationAccess().getRule();
	}
	
	//enum CSVSeparator:
	//	COMMA=',' | SEMI_COLON=";";
	public CSVSeparatorElements getCSVSeparatorAccess() {
		return eCSVSeparator;
	}
	
	public EnumRule getCSVSeparatorRule() {
		return getCSVSeparatorAccess().getRule();
	}
	
	///*
	// * mini DSL to select the ML algorithm we want 
	// * we include the choice of the targeted language/framework
	// * ML algorithms can have hyperparameters
	// * 
	// */ MLChoiceAlgorithm:
	//	'mlframework' framework=FrameworkLang
	//	'algorithm' algorithm=MLAlgorithm;
	public MLChoiceAlgorithmElements getMLChoiceAlgorithmAccess() {
		return pMLChoiceAlgorithm;
	}
	
	public ParserRule getMLChoiceAlgorithmRule() {
		return getMLChoiceAlgorithmAccess().getRule();
	}
	
	//enum FrameworkLang:
	//	SCIKIT="scikit-learn" | R | JavaWeka="Weka" | XGBoost="xgboost";
	public FrameworkLangElements getFrameworkLangAccess() {
		return eFrameworkLang;
	}
	
	public EnumRule getFrameworkLangRule() {
		return getFrameworkLangAccess().getRule();
	}
	
	//MLAlgorithm:
	//	SVR | DT | RandomForest | SGD | GTB;
	public MLAlgorithmElements getMLAlgorithmAccess() {
		return pMLAlgorithm;
	}
	
	public ParserRule getMLAlgorithmRule() {
		return getMLAlgorithmAccess().getRule();
	}
	
	//// TODO: additional algorithm
	//SVR:
	//	{SVR} 'SVR' ('C=' C=FLOAT)? ('kernel=' kernel=SVMKernel)?;
	public SVRElements getSVRAccess() {
		return pSVR;
	}
	
	public ParserRule getSVRRule() {
		return getSVRAccess().getRule();
	}
	
	//enum SVMKernel:
	//	linear | poly | rbf;
	public SVMKernelElements getSVMKernelAccess() {
		return eSVMKernel;
	}
	
	public EnumRule getSVMKernelRule() {
		return getSVMKernelAccess().getRule();
	}
	
	//DT:
	//	{DT} ('DT' | 'DecisionTree') max_depth=INT?;
	public DTElements getDTAccess() {
		return pDT;
	}
	
	public ParserRule getDTRule() {
		return getDTAccess().getRule();
	}
	
	//// TODO: additional hyperparameters
	//// note: R-package CART: anova 
	//RandomForest:
	//	{RandomForest} ('RandomForest' | 'RF');
	public RandomForestElements getRandomForestAccess() {
		return pRandomForest;
	}
	
	public ParserRule getRandomForestRule() {
		return getRandomForestAccess().getRule();
	}
	
	//// TODO: hyperparameters?
	//SGD:
	//	{SGD} ('StochasticGradientDescent' | 'SGD');
	public SGDElements getSGDAccess() {
		return pSGD;
	}
	
	public ParserRule getSGDRule() {
		return getSGDAccess().getRule();
	}
	
	//// TODO: hyperparameters?
	//GTB:
	//	{GTB} ('GradientBoostingRegressor' | 'GTB');
	public GTBElements getGTBAccess() {
		return pGTB;
	}
	
	public ParserRule getGTBRule() {
		return getGTBAccess().getRule();
	}
	
	//FLOAT:
	//	INT '.' INT;
	public FLOATElements getFLOATAccess() {
		return pFLOAT;
	}
	
	public ParserRule getFLOATRule() {
		return getFLOATAccess().getRule();
	}
	
	///*
	// * mini DSL to specify "formula"
	// * inspired from R formula 
	// */ RFormula:
	//	'formula' (predictive=FormulaItem "~")? predictors=XFormula;
	public RFormulaElements getRFormulaAccess() {
		return pRFormula;
	}
	
	public ParserRule getRFormulaRule() {
		return getRFormulaAccess().getRule();
	}
	
	//XFormula:
	//	AllVariables | PredictorVariables;
	public XFormulaElements getXFormulaAccess() {
		return pXFormula;
	}
	
	public ParserRule getXFormulaRule() {
		return getXFormulaAccess().getRule();
	}
	
	//AllVariables:
	//	all='.';
	public AllVariablesElements getAllVariablesAccess() {
		return pAllVariables;
	}
	
	public ParserRule getAllVariablesRule() {
		return getAllVariablesAccess().getRule();
	}
	
	//PredictorVariables:
	//	vars+=FormulaItem ("+" vars+=FormulaItem)*;
	public PredictorVariablesElements getPredictorVariablesAccess() {
		return pPredictorVariables;
	}
	
	public ParserRule getPredictorVariablesRule() {
		return getPredictorVariablesAccess().getRule();
	}
	
	//// by name or integer
	//FormulaItem:
	//	column=INT | colName=STRING;
	public FormulaItemElements getFormulaItemAccess() {
		return pFormulaItem;
	}
	
	public ParserRule getFormulaItemRule() {
		return getFormulaItemAccess().getRule();
	}
	
	///*
	// * mini DSL for evaluation
	// * choice of a "stratification" strategy and metric
	// */ Validation:
	//	stratification=StratificationMethod
	//	metric+=ValidationMetric+;
	public ValidationElements getValidationAccess() {
		return pValidation;
	}
	
	public ParserRule getValidationRule() {
		return getValidationAccess().getRule();
	}
	
	//StratificationMethod:
	//	CrossValidation | TrainingTest;
	public StratificationMethodElements getStratificationMethodAccess() {
		return pStratificationMethod;
	}
	
	public ParserRule getStratificationMethodRule() {
		return getStratificationMethodAccess().getRule();
	}
	
	//CrossValidation:
	//	'CrossValidation' '{'
	//	'numRepetitionCross' number=INT
	//	'}';
	public CrossValidationElements getCrossValidationAccess() {
		return pCrossValidation;
	}
	
	public ParserRule getCrossValidationRule() {
		return getCrossValidationAccess().getRule();
	}
	
	//// TODO: can certainly be extended
	//TrainingTest:
	//	'TrainingTest' '{'
	//	'percentageTraining' number=INT
	//	'}';
	public TrainingTestElements getTrainingTestAccess() {
		return pTrainingTest;
	}
	
	public ParserRule getTrainingTestRule() {
		return getTrainingTestAccess().getRule();
	}
	
	//enum ValidationMetric:
	//	MSE='mean_squared_error' | MAE='mean_absolute_error' | MAPE="mean_absolute_percentage_error";
	public ValidationMetricElements getValidationMetricAccess() {
		return eValidationMetric;
	}
	
	public EnumRule getValidationMetricRule() {
		return getValidationMetricAccess().getRule();
	}
	
	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' |
	//	"'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT:
	//	'/*'->'*/';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
